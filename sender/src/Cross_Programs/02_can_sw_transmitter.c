/*+
    SDCC - A Software-Defined CAN Controller
    Copyright (C) 2018 National Research Council of Italy and
      University of Luxembourg

    Authors: Ivan Cibrario Bertolotti and Tingting Hu

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2
    as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

    The use of the program may be restricted in certain countries by
    intellectual property rights owned by Bosch.  For more information, see:

    http://www.bosch-semiconductors.com/ip-modules/can-ip-modules/can-protocol/
+*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include <CAN_XR_Config.h>
#include <LED_Config.h>
#include <CAN_XR_PMA_GPIO.h>
#include <CAN_XR_PCS.h>
#include <CAN_XR_MAC.h>
#include <CAN_XR_Trace.h>
#include <aes.h>

//#include "bpmac.h"
#include "../../lib/bpmac/bpmac.h"  /* only for IDE, for build "bpmac.h" should work as well */

#define configCPU_CLOCK_HZ 96000000    // 96 MHz is used clock speed at Mbed development board

/* 8 quanta per bit, sampling point between quantum 5 and 6, (assuming
   the first quantum is quantum 0).  This matches the configuration of
   the hardware CAN controller performed by CAN_XR_CAN_Driver.c.
*/
const struct CAN_XR_PCS_Bit_Time_Parameters pcs_parameters = {
    .prescaler_m = 1,
    .sync_seg = 1, /* Always this way */
    .prop_seg = 3,
    .phase_seg1 = 2,
    .phase_seg2 = 2,
    .sjw = 1
};

/* The GPIO PMA takes its timing reference from Timer 0, clocked at
   the CCLK frequency, configCPU_CLOCK_HZ.  The prescaler value must
   be calculated in the same way as a normal CAN controller, starting
   from that frequency.
*/
#define GPIO_BIT_RATE CAN_XR_BIT_RATE
#define GPIO_NODECLOCK_PER_BIT (pcs_parameters.sync_seg + pcs_parameters.prop_seg + pcs_parameters.phase_seg1 + pcs_parameters.phase_seg2)
#define GPIO_PRESCALER configCPU_CLOCK_HZ/(GPIO_BIT_RATE*GPIO_NODECLOCK_PER_BIT)

struct CAN_XR_MAC mac;
struct CAN_XR_PCS pcs;
struct CAN_XR_PMA pma;
// MAC stuff
bpmac_ctx_t ctx_grp;
bpmac_ctx_t ctx_src;
uint64_t nonce_src[2] = {0, 0};
uint64_t nonce_grp[2] = {0, 0};
uint8_t grp_key[] = {0xFF, 0x00,0xFF, 0x00,0xFF, 0x00,0xFF, 0x00,0xFF, 0x00,0xFF, 0x00,0xFF, 0x00,0xFF, 0x00};
uint8_t grp_key_nonce[] = {0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF};
uint8_t src_key[] = {0x17, 0x07, 0x17, 0x07, 0x17, 0x07, 0x17, 0x07, 0x17, 0x07, 0x17, 0x07, 0x17, 0x07, 0x17, 0x07};
uint8_t src_key_nonce[] = {0x22, 0x11, 0x27, 0x09, 0x22, 0x11, 0x27, 0x09, 0x22, 0x11, 0x27, 0x09 ,0x22, 0x11, 0x27, 0x09};

// EVAL stuff
uint64_t transmission_attempts = 0;
uint8_t cnt_transmission_attempts = 1;
uint16_t transmission_state = 0;

int signal_cnt = 5;
int msg_limit = 1001000;
int msg_cnt = 0;

void dummy_data_ind(
    struct CAN_XR_LLC *llc, unsigned long ts, uint32_t identifier,
    enum CAN_XR_Format format, int dlc, uint8_t *data)
{
    switch (identifier) {
        case 384:   /* nonce reset, triggered by one receiver */
            led_on(led3);
            nonce_src[1] = (nonce_src[1] & ~((uint64_t) 0xffffff)) + 0x1000000;
            nonce_src[0] = 0;
            nonce_grp[1] = (nonce_grp[1] & ~((uint64_t) 0xffffff)) + 0x1000000;
            nonce_grp[0] = 0;
            transmission_state = 385;
            break;

        case 383:   /* (2) #correct received */
            cnt_transmission_attempts = 0;
            transmission_state = 279;
            break;

        case 525:   /* (4) #incorrect received */
            transmission_state = 999;
            break;

        case 418:   /* (5) continue received */
            transmission_attempts = 0;
            signal_cnt = 5;
            cnt_transmission_attempts = 1;
            transmission_state = 0;
            msg_cnt = 0;
            break;

        default:
            // noop
            break;
    }
}

void dummy_data_conf(
    struct CAN_XR_LLC *llc, unsigned long ts, uint32_t identifier,
    enum CAN_XR_MAC_Tx_Status transmission_status)
{
    if(transmission_status != CAN_XR_MAC_TX_STATUS_SUCCESS)
    {
        printf("< @%lu: id=%lu, transmission_status=%d\n",
               ts, (unsigned long) identifier, transmission_status);
    }
}

/* This indication is generated by the GPIO PMA on every nodeclock
   cycle and can be used to trigger requests at the application layer
   (which at this time is layered directly upon the MAC).

   This function is time-critical because PCS/bus synchronization
   depends on the accuracy of the GPIO PMA cycle.  Please don't
   printf() here unless there is an error.
*/
int app_nodeclock_ind(
    struct CAN_XR_PCS *pcs)
{

    static int msg_intervals = 1;

    if (msg_intervals++ % 60000 == 0) {     // approx. one message every ~ 20 ms @ 40kbs
        uint16_t id;
        uint8_t data_mac[16] = {0};
        uint64_t data = 0;

        switch (transmission_state) {
            case 0:     /* normal transmission */
                if (msg_cnt == 10000)     /* (1) signalize 10k messages */
                {
                    uint8_t data = 0xFF;
                    transmission_state = 999;
                    cnt_transmission_attempts = 0;
                    CAN_XR_MAC_Data_Req(&mac, 555, CAN_XR_FORMAT_CBFF, 1, &data, &data);
                    return 1;
                }
                else if (msg_cnt < msg_limit)
                {
                    reset_leds();

                    /* create random values */
                    uint8_t len = (rand() % 5) + 1; /* random length in [1, 5] */
                    data = rand();  /* random data */
                    id = rand() % 256;  /* IDs > 256 reserved for signalling purposes and not authenticated */

                    /* GROUP MAC */
                    bpmac_pre(&ctx_grp, (uint8_t *) nonce_grp, (char *) data_mac);
                    /* msg id is covert by MAC */
                    for (int8_t i = 10; i >= 0; i--) {
                        bpmac_update(&ctx_grp, (id & (1 << i)), (char *) data_mac);
                    }
                    bpmac_sign(&ctx_grp, (char *) &data, len, (char *) data_mac);
                    if (++nonce_grp[0] == 0)
                    {
                        nonce_grp[1]++;
                    }

                    /* SOURCE MAC */
                    uint8_t src_mac[16] = {0};
                    bpmac_pre(&ctx_src, (uint8_t *) nonce_src, (char *) src_mac);
                    for (int8_t i = 10; i >= 0; i--) {
                        bpmac_update(&ctx_src, (id & (1 << i)), (char *) src_mac);
                    }
                    bpmac_sign(&ctx_src, (char *) &data, len, (char *) src_mac);
                    if (++nonce_src[0] == 0)
                    {
                        nonce_src[1]++;
                    }

                    /* XOR MACS and send data */
                    ((uint32_t *) data_mac)[0] ^= ((uint32_t *) src_mac)[0];
                    CAN_XR_MAC_Data_Req(&mac, id, CAN_XR_FORMAT_CBFF, len + 3, (uint8_t *) &data, (uint8_t *) data_mac);
                    msg_cnt++;
                    return 1;
                }

            case 279:   /* (3) send #transmission attempts */
                transmission_state = 999;
                CAN_XR_MAC_Data_Req(&mac, 279, CAN_XR_FORMAT_CBFF, 8, (uint8_t *) &transmission_attempts,
                                    (uint8_t *) &transmission_attempts);
                led_set_all();
                return 1;

            case 385:   /* send new nonce value to authenticator */
                id = 385;
                led_on(led1);
                data = 0;
                for (uint8_t i = 0; i < 5; i++)
                {
                    ((uint8_t *) &data)[i] = ((uint8_t *) &nonce_src[1])[i + 3];
                }

                /* one-to-one communication, thus single source MAC is sufficient */
                bpmac_pre(&ctx_src, (uint8_t *) nonce_src, (char *) data_mac);
                for (int8_t i = 10; i >= 0; i--) {
                    bpmac_update(&ctx_src, (id & (1 << i)), (char *) data_mac);
                }
                bpmac_sign(&ctx_src, (char *) &data, 5, (char *) data_mac);
                if (++nonce_src[0] == 0)
                {
                    nonce_src[1]++;
                }

                for (uint8_t i = 5; i < 8; i++)
                {
                    ((uint8_t *) &data)[i] = data_mac[i - 4];
                }

                CAN_XR_MAC_Data_Req(&mac, id, CAN_XR_FORMAT_CBFF, 8, (uint8_t *) &data, (uint8_t *) data_mac);

                transmission_state = 200;
                return 1;

            case 200:   /* send new nonce value to all receivers */
                id = 200;
                led_on(led2);
                data = 0;
                for (uint8_t i = 0; i < 5; i++)
                {
                    ((uint8_t *) &data)[i] = ((uint8_t *) &nonce_grp[1])[i + 3];
                }

                /* one-to-many communication and authenticator has updated, thus CAIBA secured */
                /* GROUP MAC */
                bpmac_pre(&ctx_grp, (uint8_t *) nonce_grp, (char *) data_mac);
                for (int8_t i = 10; i >= 0; i--) {
                    bpmac_update(&ctx_grp, (id & (1 << i)), (char *) data_mac);
                }
                bpmac_sign(&ctx_grp, (char *) &data, 5, (char *) data_mac);
                if (++nonce_grp[0] == 0)
                {
                    nonce_grp[1]++;
                }

                /* SOURCE MAC */
                uint8_t src_mac[16] = {0};
                bpmac_pre(&ctx_src, (uint8_t *) nonce_src, (char *) src_mac);
                for (int8_t i = 10; i >= 0; i--) {
                    bpmac_update(&ctx_src, (id & (1 << i)), (char *) src_mac);
                }
                bpmac_sign(&ctx_src, (char *) &data, 5, (char *) src_mac);
                if (++nonce_src[0] == 0)
                {
                    nonce_src[1]++;
                }

                ((uint32_t *) data_mac)[0] ^= ((uint32_t *) src_mac)[0];
                CAN_XR_MAC_Data_Req(&mac, id, CAN_XR_FORMAT_CBFF, 8, (uint8_t *) &data, (uint8_t *) data_mac);
                transmission_state = 0;
                return 1;

            default:
                return 0;
        }

    }
    return 0;
}



int main(int argc, char *argv[])
{
    enable_leds();

    bpmac_init((char *) grp_key, (char *) grp_key_nonce, 8, &ctx_grp);
    bpmac_init((char *) src_key, (char *) src_key_nonce, 8, &ctx_src);

    CAN_XR_PMA_GPIO_Init(&pma, GPIO_PRESCALER);
    CAN_XR_PCS_Init(&pcs, &pcs_parameters, &pma);

    /* TBD: To be replaced by implementation-specific initialization
       function when there's one. */
    CAN_XR_MAC_Common_Init(&mac, &pcs);

    /* Register app_nodeclock_ind to trigger the transmission */
    CAN_XR_PMA_GPIO_Set_App_NodeClock_Ind(&pma, app_nodeclock_ind);

    /* Register dummy data_ind and data_conf primitives in 'mac'. */
    CAN_XR_MAC_Set_Data_Ind(&mac, dummy_data_ind);

    /* Start the controller, feeding it with nodeclock indications. */
    SET_TRACE_TRESHOLD(3);
    CAN_XR_PMA_GPIO_NodeClock_Ind(&pma);

    return EXIT_SUCCESS;
}
